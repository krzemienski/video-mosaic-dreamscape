import { ExtendedCategory, VideoItem, AwesomeVideoContents, AwesomeVideoCategory } from '@/types/video';

interface RawCategory {
  id: string;
  title: string;
  description?: string;
  parent?: string;
  subcategories?: RawCategory[];
  videos?: VideoItem[];
}

interface CategoryMapItem extends RawCategory {
  subcategories: RawCategory[];
  videos: VideoItem[];
}

interface RawContents extends AwesomeVideoContents {
  model_used?: string;
  provider?: string;
  project_count?: number;
  projects: VideoItem[];
}

// Function to convert awesome-video data to our ExtendedCategory format
export const transformAwesomeVideoData = (contents: RawContents): ExtendedCategory[] => {
  console.log('Starting data transformation');

  if (!contents) {
    console.error('Contents is null or undefined');
    return [];
  }

  // Print exactly what the contents structure looks like for debugging
  console.log('Raw contents structure:', JSON.stringify(contents, null, 2).substring(0, 1000) + '...');
  console.log('Content keys:', Object.keys(contents).join(', '));

  if (contents.model_used) {
    console.log(`Data generated by model: ${contents.model_used} (${contents.provider})`);
  }

  if (contents.project_count) {
    console.log(`Total project count: ${contents.project_count}`);
  }

  // Log some statistics about projects to understand the data better
  if (contents.projects && Array.isArray(contents.projects)) {
    console.log(`Total projects in data: ${contents.projects.length}`);

    // Count how many projects have specific category/subcategory fields
    const projectsWithCategory = contents.projects.filter(p => p.category).length;
    const projectsWithSubcategory = contents.projects.filter(p => p.subcategory).length;
    const projectsWithCategoriesArray = contents.projects.filter(p => Array.isArray(p.categories)).length;
    const projectsWithSubcategoriesArray = contents.projects.filter(p => Array.isArray(p.subcategories)).length;

    console.log(`Projects with direct category: ${projectsWithCategory}`);
    console.log(`Projects with direct subcategory: ${projectsWithSubcategory}`);
    console.log(`Projects with categories array: ${projectsWithCategoriesArray}`);
    console.log(`Projects with subcategories array: ${projectsWithSubcategoriesArray}`);
  }

  // Handle the recategorized structure from awesome-video repository
  if (contents.categories && Array.isArray(contents.categories)) {
    console.log(`Processing ${contents.categories.length} categories in contents`);

    // First, create a map of all categories by ID for easy lookup
    const categoryMap = new Map<string, CategoryMapItem>();
    contents.categories.forEach((category: RawCategory) => {
      categoryMap.set(category.id, {
        ...category,
        subcategories: [],
        videos: []
      });
    });

    // Now build the hierarchy by connecting parents and children
    contents.categories.forEach((category: RawCategory) => {
      if (category.parent) {
        const parentCategory = categoryMap.get(category.parent);
        if (parentCategory) {
          parentCategory.subcategories.push(categoryMap.get(category.id) as RawCategory);
        }
      }
    });

    // Map top-level categories first (those without parent)
    const topLevelCategories = contents.categories.filter((category: RawCategory) => !category.parent);
    console.log(`Found ${topLevelCategories.length} top-level categories`);

    // Process each top-level category and its subcategories
    return topLevelCategories.map((category: RawCategory, index: number) => {
      return processCategoryWithProjects(category, index, contents, categoryMap);
    });
  } else {
    console.error('Invalid or missing categories array in contents');
    return [];
  }
};

// Revised getProjectsForCategory: support singular/plural category and array properties
const getProjectsForCategory = (categoryId: string, projects: VideoItem[]): VideoItem[] => {
  if (!categoryId || !projects || projects.length === 0) {
    return [];
  }
  console.log(`Looking for projects with category ID: ${categoryId}`);
  if (projects.length > 0) {
    const sampleProject = projects[0];
    console.log('Sample project structure:', {
      id: sampleProject.id,
      title: sampleProject.title,
      category: sampleProject.category,
      categories: sampleProject.categories,
      subcategory: sampleProject.subcategory,
      subcategories: sampleProject.subcategories,
      homepage: (sampleProject as any).homepage,
    });
  }
  return projects.filter((project: VideoItem & Record<string, any>) => {
    if (project.category === categoryId) return true;
    if (Array.isArray((project as any).category) && (project as any).category.includes(categoryId)) return true;
    if (Array.isArray(project.categories) && project.categories.includes(categoryId)) return true;
    if (project.subcategory === categoryId) return true;
    if (Array.isArray((project as any).subcategory) && (project as any).subcategory.includes(categoryId)) return true;
    if (Array.isArray(project.subcategories) && project.subcategories.includes(categoryId)) return true;
    return false;
  });
};

// Process a category and its associated projects
const processCategoryWithProjects = (
  category: RawCategory,
  index: number,
  contents: RawContents,
  categoryMap: Map<string, CategoryMapItem>
): ExtendedCategory => {
  const categoryId = category.id || '';
  const categoryName = category.title || '';
  const categoryDescription = category.description || `Resources related to ${categoryName}`;
  const slug = categoryName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

  console.log(`Processing category ${index}: ${categoryName} (ID: ${categoryId})`);

  // Get the category from our map which includes subcategories
  const mappedCategory = categoryMap.get(categoryId);
  if (!mappedCategory) {
    throw new Error(`Category ${categoryId} not found in map`);
  }

  // Find all projects belonging directly to this category
  const categoryProjects = getProjectsForCategory(categoryId, contents.projects);
  console.log(`Category "${categoryName}" has ${categoryProjects.length} direct projects`);

  const subcategories = mappedCategory.subcategories.map((subcat: RawCategory, subIndex: number) => {
    const subcatName = subcat.title || '';
    const subcatId = subcat.id || '';
    const subcatDescription = subcat.description || `Resources related to ${subcatName}`;
    const subcatSlug = subcatName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

    console.log(`Processing subcategory ${subcatName} (ID: ${subcatId}) of ${categoryName}`);

    // Find all projects belonging to this subcategory
    const subcatProjects = getProjectsForCategory(subcatId, contents.projects);
    console.log(`Subcategory "${subcatName}" has ${subcatProjects.length} direct projects`);

    // Process nested subcategories recursively
    const nestedSubcategories = (subcat.subcategories || []).map((nested: RawCategory, nestedIndex: number) => {
      const nestedName = nested.title || '';
      const nestedId = nested.id || '';
      const nestedDescription = nested.description || `Resources related to ${nestedName}`;
      const nestedSlug = nestedName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

      console.log(`Processing nested subcategory ${nestedName} (ID: ${nestedId}) of ${subcatName}`);

      // Find all projects belonging to this nested subcategory
      const nestedProjects = getProjectsForCategory(nestedId, contents.projects);
      console.log(`Nested subcategory "${nestedName}" has ${nestedProjects.length} projects`);

      return {
        id: `${index}-sub-${subIndex}-nested-${nestedIndex}`,
        name: nestedName,
        slug: nestedSlug,
        description: nestedDescription,
        count: nestedProjects.length,
        videos: nestedProjects.map((project: VideoItem, projectIndex: number) =>
          mapProjectToVideoItem(project, index, subIndex, projectIndex)
        ),
      };
    });

    // Calculate total count for this subcategory (direct + nested)
    const totalSubcatCount = subcatProjects.length +
      nestedSubcategories.reduce((sum, nested) => sum + (nested.count || 0), 0);

    console.log(`Subcategory "${subcatName}" total count: ${totalSubcatCount} (direct: ${subcatProjects.length}, nested: ${totalSubcatCount - subcatProjects.length})`);

    return {
      id: `${index}-sub-${subIndex}`,
      name: subcatName,
      slug: subcatSlug,
      description: subcatDescription,
      count: totalSubcatCount,
      videos: subcatProjects.map((project: VideoItem, projectIndex: number) =>
        mapProjectToVideoItem(project, index, subIndex, projectIndex)
      ),
      subcategories: nestedSubcategories.length > 0 ? nestedSubcategories : undefined,
    };
  });

  // Calculate total projects (direct + in subcategories and nested subcategories)
  const totalProjectCount = categoryProjects.length +
    subcategories.reduce((sum, sub) => sum + (sub.count || 0), 0);

  console.log(`Category "${categoryName}" total count: ${totalProjectCount} (direct: ${categoryProjects.length}, in subcategories: ${totalProjectCount - categoryProjects.length})`);

  return {
    id: `cat-${index}`,
    name: categoryName,
    slug,
    description: categoryDescription,
    imageUrl: `/images/category-${index % 6 + 1}.jpg`, // Cycle through 6 placeholder images
    count: totalProjectCount,
    videoCount: categoryProjects.length, // Direct videos only
    subcategoryCount: subcategories.length,
    videos: categoryProjects.map((project: VideoItem, projectIndex: number) =>
      mapProjectToVideoItem(project, index, null, projectIndex)
    ),
    subcategories,
  };
};

// Updated mapProjectToVideoItem: use homepage as fallback for URL
const mapProjectToVideoItem = (
  project: VideoItem,
  categoryIndex: number,
  subcategoryIndex: number | null,
  projectIndex: number
): VideoItem => {
  const idPrefix = subcategoryIndex !== null
    ? `${categoryIndex}-${subcategoryIndex}-item-`
    : `${categoryIndex}-item-`;

  return {
    id: `${idPrefix}${projectIndex}`,
    title: project.title,
    url: project.url || (project as any).homepage || '',
    description: project.description,
    tags: project.tags || [],
  };
};

// Helper function to fetch content using CORS proxy if needed
export const fetchContentWithCorsHandling = async (url: string): Promise<RawContents> => {
  console.log(`Fetching content from URL: ${url}`);

  // Get the content URL from environment variables if available
  const contentUrl = import.meta.env.VITE_CONTENT_URL || url;
  console.log(`Using content URL: ${contentUrl}`);

  try {
    // First attempt: Direct fetch with CORS mode
    console.log('Attempting direct fetch with CORS mode');
    const response = await fetch(contentUrl, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      },
      mode: 'cors',
      credentials: 'omit'
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const text = await response.text();
    console.log(`Received ${text.length} bytes of data`);

    try {
      const json = JSON.parse(text);
      console.log('Content successfully parsed as JSON');
      return json;
    } catch (e) {
      console.error('Failed to parse response as JSON:', e);
      throw new Error('Invalid JSON response');
    }
  } catch (error) {
    console.error('Error fetching content:', error);

    // First fallback: Try with CORS proxy - allorigins
    try {
      console.log('Attempting to use CORS proxy (allorigins)');
      const corsProxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(contentUrl)}`;

      const proxyResponse = await fetch(corsProxyUrl);
      if (!proxyResponse.ok) {
        throw new Error(`Proxy HTTP error! Status: ${proxyResponse.status}`);
      }

      const proxyText = await proxyResponse.text();
      console.log(`Received ${proxyText.length} bytes of data via proxy`);

      const proxyJson = JSON.parse(proxyText);
      console.log('Content successfully parsed as JSON via proxy');
      return proxyJson;
    } catch (proxyError) {
      console.error('First CORS proxy attempt failed:', proxyError);

      // Second fallback: Try with a different CORS proxy - corsproxy.io
      try {
        console.log('Attempting with alternate CORS proxy (corsproxy.io)');
        const corsProxyAlt = `https://corsproxy.io/?${encodeURIComponent(contentUrl)}`;

        const altProxyResponse = await fetch(corsProxyAlt);
        if (!altProxyResponse.ok) {
          throw new Error(`Alt proxy HTTP error! Status: ${altProxyResponse.status}`);
        }

        const altProxyText = await altProxyResponse.text();
        const altProxyJson = JSON.parse(altProxyText);
        console.log('Content successfully parsed via alternate proxy');
        return altProxyJson;
      } catch (altProxyError) {
        console.error('All proxies failed:', altProxyError);
        throw new Error('Unable to fetch content: CORS or network issues detected');
      }
    }
  }
};

// Helper function for debugging - examine a URL's content structure
export const examineUrlContent = async (url: string): Promise<RawContents> => {
  try {
    console.log(`Examining content from URL: ${url}`);

    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'Cache-Control': 'no-cache'
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const text = await response.text();
    console.log(`Received ${text.length} bytes of data`);

    try {
      const json = JSON.parse(text) as RawContents;
      console.log('Content structure keys:', Object.keys(json).join(', '));
      return json;
    } catch (e) {
      console.error('Not valid JSON:', e);
      throw new Error('Invalid JSON data received');
    }
  } catch (error) {
    console.error('Error examining URL:', error);
    throw error;
  }
};
